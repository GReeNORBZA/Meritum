{
  "domainNumber": "01",
  "domainName": "Identity & Access Management",
  "manifestFile": "domain-01-iam.tasks",
  "promptPrefix": "d01",
  "modulePath": "apps/api/src/domains/iam",
  "sections": [
    {
      "title": "Domain 1: Identity & Access — Shared Types & Constants",
      "tasks": [
        {
          "id": "D01-001",
          "description": "Permission constants, role enums, audit action identifiers, subscription statuses",
          "verify": "pnpm --filter shared build",
          "build": [
            "Create `packages/shared/src/constants/iam.constants.ts` with all IAM constants:",
            "",
            "**Roles enum:**",
            "- PHYSICIAN, DELEGATE, ADMIN",
            "",
            "**Permission keys (24 total):**",
            "- CLAIM_CREATE, CLAIM_VIEW, CLAIM_EDIT, CLAIM_DELETE, CLAIM_SUBMIT",
            "- BATCH_VIEW, BATCH_APPROVE",
            "- PATIENT_CREATE, PATIENT_VIEW, PATIENT_EDIT, PATIENT_IMPORT",
            "- REPORT_VIEW, REPORT_EXPORT",
            "- ANALYTICS_VIEW",
            "- PROVIDER_VIEW, PROVIDER_EDIT",
            "- DELEGATE_MANAGE",
            "- SUBSCRIPTION_MANAGE",
            "- SETTINGS_VIEW, SETTINGS_EDIT",
            "- DATA_EXPORT",
            "- AUDIT_VIEW",
            "- AI_COACH_VIEW, AI_COACH_MANAGE",
            "",
            "**Default permission sets:**",
            "- PHYSICIAN: all 24 permissions",
            "- DELEGATE: subset configured per linkage (no DELEGATE_MANAGE, no SUBSCRIPTION_MANAGE, no DATA_EXPORT, no AUDIT_VIEW by default)",
            "- ADMIN: all permissions + ADMIN_PHI_ACCESS",
            "",
            "**Audit action identifiers (28 categories):**",
            "- auth.registered, auth.email_verified, auth.mfa_setup, auth.login_success, auth.login_failed, auth.login_mfa_success, auth.login_mfa_failed, auth.login_recovery_used, auth.logout, auth.session_revoked, auth.session_revoked_all, auth.password_reset_requested, auth.password_reset_completed",
            "- delegate.invited, delegate.accepted, delegate.permissions_updated, delegate.revoked, delegate.context_switched",
            "- account.updated, account.mfa_reconfigured, account.recovery_codes_regenerated, account.deletion_requested, account.deletion_executed, account.suspended, account.reactivated",
            "- audit.queried, audit.exported",
            "- admin.mfa_reset_issued",
            "",
            "**Subscription statuses:** TRIAL, ACTIVE, PAST_DUE, SUSPENDED, CANCELLED",
            "",
            "**Session revoke reasons:** logout, expired_idle, expired_absolute, revoked_remote, password_reset, account_deleted",
            "",
            "Export all as frozen objects / TypeScript enums. These are consumed by the API and frontend."
          ],
          "frd": [
            "Domain 1 Section 2: 24 permissions across 3 roles. Physician has all permissions. Delegate permissions are configurable per linkage. Admin has all permissions plus ADMIN_PHI_ACCESS.",
            "Domain 1 Section 6: 28 audit action identifiers across 5 categories (auth, delegate, account, audit, admin). Each action has a category, action name, and logged detail specification."
          ]
        },
        {
          "id": "D01-002",
          "description": "Drizzle schema for users table",
          "verify": "pnpm --filter shared build",
          "depends": ["D01-001"],
          "build": [
            "Create `packages/shared/src/schemas/db/iam.schema.ts` starting with the users table.",
            "",
            "**users table:**",
            "",
            "| Column | Type | Constraints | Notes |",
            "|--------|------|-------------|-------|",
            "| user_id | UUID | PK | Default: gen_random_uuid() |",
            "| email | VARCHAR(255) | NOT NULL, UNIQUE | Normalised to lowercase |",
            "| password_hash | VARCHAR(255) | NOT NULL | Argon2id hash |",
            "| full_name | VARCHAR(200) | NOT NULL | Display name |",
            "| phone | VARCHAR(20) | NULLABLE | For support recovery |",
            "| role | VARCHAR(20) | NOT NULL, DEFAULT 'physician' | physician, delegate, admin |",
            "| email_verified | BOOLEAN | NOT NULL, DEFAULT false | Set true on verification |",
            "| mfa_configured | BOOLEAN | NOT NULL, DEFAULT false | Set true after MFA setup |",
            "| totp_secret_encrypted | TEXT | NULLABLE | AES-256-GCM encrypted TOTP secret |",
            "| subscription_status | VARCHAR(20) | NOT NULL, DEFAULT 'trial' | Stripe-driven status |",
            "| failed_login_count | INTEGER | NOT NULL, DEFAULT 0 | Reset on successful login |",
            "| locked_until | TIMESTAMPTZ | NULLABLE | Set after 10 failed logins (30 min lock) |",
            "| is_active | BOOLEAN | NOT NULL, DEFAULT true | Soft delete |",
            "| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() | |",
            "| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() | |",
            "",
            "**Indexes:** unique on email, index on (role, is_active), index on subscription_status.",
            "",
            "Export the table and its inferred types (InsertUser, SelectUser) from the schema file."
          ],
          "security": [
            "totp_secret_encrypted is AES-256-GCM encrypted. The encryption key is stored in environment variables, never in the database.",
            "password_hash uses Argon2id with parameters: memory 19456 KiB, iterations 2, parallelism 1.",
            "email is normalised to lowercase before storage to prevent duplicate accounts with case variation."
          ]
        },
        {
          "id": "D01-003",
          "description": "Drizzle schema for recovery_codes, sessions, invitation_tokens tables",
          "verify": "pnpm --filter shared build",
          "depends": ["D01-002"],
          "build": [
            "Add to `packages/shared/src/schemas/db/iam.schema.ts`:",
            "",
            "**recovery_codes table:**",
            "",
            "| Column | Type | Constraints |",
            "|--------|------|-------------|",
            "| code_id | UUID | PK |",
            "| user_id | UUID FK | NOT NULL, FK → users |",
            "| code_hash | VARCHAR(255) | NOT NULL (Argon2id hash) |",
            "| used | BOOLEAN | NOT NULL, DEFAULT false |",
            "| created_at | TIMESTAMPTZ | NOT NULL |",
            "",
            "Index: (user_id, used) for finding unused codes.",
            "",
            "**sessions table:**",
            "",
            "| Column | Type | Constraints |",
            "|--------|------|-------------|",
            "| session_id | UUID | PK |",
            "| user_id | UUID FK | NOT NULL, FK → users |",
            "| token_hash | VARCHAR(255) | NOT NULL, UNIQUE |",
            "| ip_address | VARCHAR(45) | NOT NULL |",
            "| user_agent | TEXT | NOT NULL |",
            "| created_at | TIMESTAMPTZ | NOT NULL |",
            "| last_active_at | TIMESTAMPTZ | NOT NULL |",
            "| revoked | BOOLEAN | NOT NULL, DEFAULT false |",
            "| revoked_reason | VARCHAR(30) | NULLABLE |",
            "",
            "Indexes: unique on token_hash, (user_id, revoked) for active sessions, (last_active_at) for cleanup.",
            "",
            "**invitation_tokens table:**",
            "",
            "| Column | Type | Constraints |",
            "|--------|------|-------------|",
            "| invitation_id | UUID | PK |",
            "| physician_user_id | UUID FK | NOT NULL, FK → users |",
            "| delegate_email | VARCHAR(255) | NOT NULL |",
            "| token_hash | VARCHAR(255) | NOT NULL, UNIQUE |",
            "| permissions | JSONB | NOT NULL |",
            "| expires_at | TIMESTAMPTZ | NOT NULL |",
            "| accepted | BOOLEAN | NOT NULL, DEFAULT false |",
            "| created_at | TIMESTAMPTZ | NOT NULL |",
            "",
            "Index: (token_hash), (physician_user_id, accepted)."
          ],
          "security": [
            "Session tokens: only the SHA-256 hash is stored. Plaintext exists only in the HTTP-only cookie.",
            "Invitation tokens: only the SHA-256 hash is stored. Plaintext exists only in the email link.",
            "Recovery codes: hashed with Argon2id (same as passwords). Original shown once at generation."
          ]
        },
        {
          "id": "D01-004",
          "description": "Drizzle schema for delegate_linkages and audit_log tables",
          "verify": "pnpm --filter shared build",
          "depends": ["D01-002"],
          "build": [
            "Add to `packages/shared/src/schemas/db/iam.schema.ts`:",
            "",
            "**delegate_linkages table:**",
            "",
            "| Column | Type | Constraints |",
            "|--------|------|-------------|",
            "| linkage_id | UUID | PK |",
            "| physician_user_id | UUID FK | NOT NULL, FK → users |",
            "| delegate_user_id | UUID FK | NOT NULL, FK → users |",
            "| permissions | JSONB | NOT NULL (array of permission keys) |",
            "| can_approve_batches | BOOLEAN | NOT NULL, DEFAULT false |",
            "| is_active | BOOLEAN | NOT NULL, DEFAULT true |",
            "| created_at | TIMESTAMPTZ | NOT NULL |",
            "| updated_at | TIMESTAMPTZ | NOT NULL |",
            "",
            "Constraints: UNIQUE(physician_user_id, delegate_user_id). Index on (delegate_user_id, is_active).",
            "",
            "**audit_log table:**",
            "",
            "| Column | Type | Constraints |",
            "|--------|------|-------------|",
            "| log_id | UUID | PK |",
            "| user_id | UUID FK | NULLABLE (null for system actions) |",
            "| action | VARCHAR(50) | NOT NULL |",
            "| category | VARCHAR(20) | NOT NULL |",
            "| resource_type | VARCHAR(50) | NULLABLE |",
            "| resource_id | UUID | NULLABLE |",
            "| detail | JSONB | NULLABLE (action-specific metadata) |",
            "| ip_address | VARCHAR(45) | NULLABLE |",
            "| user_agent | TEXT | NULLABLE |",
            "| created_at | TIMESTAMPTZ | NOT NULL |",
            "",
            "Indexes: (user_id, created_at DESC), (action, created_at DESC), (resource_type, resource_id, created_at DESC). Partition by month for query performance.",
            "",
            "**CRITICAL:** Audit log is append-only. No UPDATE or DELETE operations. 7-year retention."
          ],
          "security": [
            "Audit log must be append-only. The repository must NOT expose update or delete functions.",
            "Audit log queries are themselves logged (action: audit.queried).",
            "JSONB detail field must never contain plaintext passwords, TOTP secrets, or session tokens."
          ]
        },
        {
          "id": "D01-005",
          "description": "Zod validation schemas for auth and session endpoints",
          "verify": "pnpm --filter shared build",
          "depends": ["D01-001"],
          "build": [
            "Create `packages/shared/src/schemas/iam.schema.ts` with Zod schemas for request/response validation:",
            "",
            "**Registration:**",
            "- registerSchema: { email: email().max(255), password: string().min(12) with uppercase+lowercase+digit+special regex, full_name: string().min(1).max(200), phone: string().max(20).optional() }",
            "",
            "**Email verification:**",
            "- verifyEmailSchema: { token: string().uuid() }",
            "",
            "**MFA setup:**",
            "- mfaConfirmSchema: { totp_code: string().length(6).regex(/^\\d{6}$/) }",
            "",
            "**Login:**",
            "- loginSchema: { email: email().max(255), password: string().min(1) }",
            "- loginMfaSchema: { mfa_session_token: string(), totp_code: string().length(6).regex(/^\\d{6}$/) }",
            "- loginRecoverySchema: { mfa_session_token: string(), recovery_code: string() }",
            "",
            "**Password reset:**",
            "- passwordResetRequestSchema: { email: email().max(255) }",
            "- passwordResetSchema: { token: string().uuid(), new_password: <same rules as register> }",
            "",
            "**Session:**",
            "- sessionIdParamSchema: { id: string().uuid() }",
            "",
            "Export all schemas AND their inferred TypeScript types (z.infer<typeof schema>)."
          ],
          "frd": [
            "Domain 1 Section 9: Email validated against RFC 5322, normalised to lowercase, max 255 chars. Password: min 12 chars, must contain uppercase, lowercase, digit, and special character. TOTP code: exactly 6 digits. Invitation token: UUID format."
          ]
        },
        {
          "id": "D01-006",
          "description": "Zod validation schemas for delegate and account endpoints",
          "verify": "pnpm --filter shared build",
          "depends": ["D01-001", "D01-005"],
          "build": [
            "Add to `packages/shared/src/schemas/iam.schema.ts`:",
            "",
            "**Delegate management:**",
            "- delegateInviteSchema: { email: email().max(255), permissions: array(enum(PERMISSION_KEYS)).min(1) }",
            "- delegateUpdatePermissionsSchema: { permissions: array(enum(PERMISSION_KEYS)).min(1) }",
            "- delegateAcceptSchema: { token: string(), full_name: string().min(1).max(200).optional(), password: <password rules>.optional() } (full_name and password required only for new users)",
            "- delegateIdParamSchema: { id: string().uuid() }",
            "",
            "**Account management:**",
            "- accountUpdateSchema: { full_name: string().min(1).max(200).optional(), phone: string().max(20).optional() }",
            "- accountDeleteSchema: { password: string().min(1), totp_code: string().length(6), confirmation: literal('DELETE') }",
            "- mfaReconfigureSchema: { current_totp_code: string().length(6) }",
            "",
            "**Audit log query:**",
            "- auditLogQuerySchema: { action: string().optional(), category: string().optional(), start_date: string().date().optional(), end_date: string().date().optional(), page: number().int().min(1).default(1), page_size: number().int().min(1).max(200).default(50) }",
            "",
            "Export all schemas and inferred types."
          ]
        },
        {
          "id": "D01-007",
          "description": "Generate and apply database migration",
          "verify": "cd apps/api && pnpm drizzle-kit generate 2>&1 && pnpm drizzle-kit migrate 2>&1",
          "depends": ["D01-002", "D01-003", "D01-004"],
          "build": [
            "Run the Drizzle migration generator to create the initial migration for all IAM tables:",
            "",
            "```bash",
            "cd apps/api",
            "pnpm drizzle-kit generate",
            "pnpm drizzle-kit migrate",
            "```",
            "",
            "Verify that the migration file was created in `apps/api/drizzle/migrations/`.",
            "Verify that all 6 tables exist in the test database: users, recovery_codes, sessions, delegate_linkages, invitation_tokens, audit_log.",
            "Verify all indexes and constraints are applied."
          ]
        }
      ]
    },
    {
      "title": "Domain 1: Identity & Access — Repository Layer",
      "tasks": [
        {
          "id": "D01-010",
          "description": "Repository: user CRUD operations",
          "verify": "pnpm --filter api vitest run src/domains/iam/iam.test.ts",
          "depends": ["D01-007"],
          "build": [
            "Create `apps/api/src/domains/iam/iam.repository.ts` with user operations:",
            "",
            "- `createUser(data: InsertUser)` — insert new user. Lowercase email before insert.",
            "- `findUserByEmail(email: string)` — find by normalised email. Include is_active check.",
            "- `findUserById(userId: string)` — find by UUID.",
            "- `updateUser(userId: string, data: Partial<UpdateUser>)` — update allowed fields. Set updated_at.",
            "- `incrementFailedLogin(userId: string)` — increment failed_login_count. If >= 10, set locked_until to now + 30 minutes.",
            "- `resetFailedLogin(userId: string)` — set failed_login_count to 0, clear locked_until.",
            "- `isAccountLocked(userId: string)` — return true if locked_until > now.",
            "- `setMfaSecret(userId: string, encryptedSecret: string)` — store encrypted TOTP secret.",
            "- `setMfaConfigured(userId: string)` — set mfa_configured = true.",
            "- `deactivateUser(userId: string)` — set is_active = false (soft delete).",
            "",
            "Create `apps/api/src/domains/iam/iam.test.ts` with unit tests for each function."
          ],
          "security": [
            "findUserByEmail normalises email to lowercase before query.",
            "updateUser must NOT allow updating email, password_hash, or totp_secret_encrypted through this function (separate dedicated functions).",
            "isAccountLocked must use database time (now()), not application time, to prevent clock skew bypass."
          ],
          "tests": [
            "createUser stores user with lowercase email",
            "createUser rejects duplicate email",
            "findUserByEmail is case-insensitive",
            "findUserByEmail excludes inactive users",
            "incrementFailedLogin locks account after 10 failures",
            "resetFailedLogin clears lock",
            "isAccountLocked returns true during lock period",
            "isAccountLocked returns false after lock expires",
            "deactivateUser sets is_active to false"
          ]
        },
        {
          "id": "D01-011",
          "description": "Repository: session management",
          "verify": "pnpm --filter api vitest run src/domains/iam/iam.test.ts",
          "depends": ["D01-007"],
          "build": [
            "Add to `apps/api/src/domains/iam/iam.repository.ts` — session operations:",
            "",
            "- `createSession(data: { userId, tokenHash, ipAddress, userAgent })` — insert session.",
            "- `findSessionByTokenHash(tokenHash: string)` — find non-revoked session. Join with users to get role, subscription_status.",
            "- `refreshSession(sessionId: string)` — update last_active_at to now().",
            "- `revokeSession(sessionId: string, reason: RevokeReason)` — set revoked = true, revoked_reason.",
            "- `revokeAllUserSessions(userId: string, exceptSessionId?: string, reason: RevokeReason)` — revoke all sessions for user except optionally the current one.",
            "- `listActiveSessions(userId: string)` — list non-revoked sessions with ip, user_agent, created_at, last_active_at.",
            "- `isSessionExpired(session)` — check absolute (24h from created_at) and idle (60min from last_active_at) expiry.",
            "- `cleanupExpiredSessions()` — delete sessions where revoked=true AND created_at < 30 days ago (housekeeping)."
          ],
          "security": [
            "findSessionByTokenHash must check revoked = false AND not expired (both absolute and idle).",
            "Session validation must be constant-time to prevent timing attacks on token_hash comparison (use database WHERE clause, not application-level comparison).",
            "listActiveSessions only returns sessions for the specified userId — no cross-user leakage."
          ],
          "tests": [
            "createSession stores session with hashed token",
            "findSessionByTokenHash returns session with user data",
            "findSessionByTokenHash returns null for revoked session",
            "findSessionByTokenHash returns null for expired session (absolute)",
            "findSessionByTokenHash returns null for expired session (idle)",
            "refreshSession updates last_active_at",
            "revokeSession sets revoked flag and reason",
            "revokeAllUserSessions revokes all except current",
            "listActiveSessions returns only non-revoked sessions",
            "cleanupExpiredSessions removes old revoked sessions"
          ]
        },
        {
          "id": "D01-012",
          "description": "Repository: recovery codes and invitation tokens",
          "verify": "pnpm --filter api vitest run src/domains/iam/iam.test.ts",
          "depends": ["D01-007"],
          "build": [
            "Add to `apps/api/src/domains/iam/iam.repository.ts`:",
            "",
            "**Recovery codes:**",
            "- `createRecoveryCodes(userId: string, codeHashes: string[])` — bulk insert 10 hashed codes. Delete any existing unused codes for this user first.",
            "- `findUnusedRecoveryCode(userId: string)` — return all unused codes for Argon2id comparison in service layer.",
            "- `markRecoveryCodeUsed(codeId: string)` — set used = true.",
            "- `countRemainingCodes(userId: string)` — count unused codes.",
            "",
            "**Invitation tokens:**",
            "- `createInvitation(data: { physicianUserId, delegateEmail, tokenHash, permissions, expiresAt })` — insert invitation.",
            "- `findInvitationByTokenHash(tokenHash: string)` — find non-accepted, non-expired invitation.",
            "- `markInvitationAccepted(invitationId: string)` — set accepted = true.",
            "- `listPendingInvitations(physicianUserId: string)` — list non-accepted, non-expired invitations."
          ],
          "security": [
            "Recovery codes are Argon2id hashed. Comparison happens in the service layer by loading all unused hashes and comparing one by one (constant-time per comparison).",
            "createRecoveryCodes deletes existing unused codes first — regeneration invalidates all previous codes.",
            "findInvitationByTokenHash must check both accepted = false AND expires_at > now()."
          ],
          "tests": [
            "createRecoveryCodes inserts 10 codes",
            "createRecoveryCodes deletes previous unused codes",
            "markRecoveryCodeUsed sets used flag",
            "countRemainingCodes returns correct count",
            "createInvitation stores invitation with hashed token",
            "findInvitationByTokenHash returns null for accepted invitation",
            "findInvitationByTokenHash returns null for expired invitation",
            "listPendingInvitations excludes accepted and expired"
          ]
        },
        {
          "id": "D01-013",
          "description": "Repository: delegate linkages",
          "verify": "pnpm --filter api vitest run src/domains/iam/iam.test.ts",
          "depends": ["D01-007"],
          "build": [
            "Add to `apps/api/src/domains/iam/iam.repository.ts`:",
            "",
            "- `createDelegateLinkage(data: { physicianUserId, delegateUserId, permissions, canApproveBatches })` — insert linkage.",
            "- `findLinkage(physicianUserId: string, delegateUserId: string)` — find active linkage.",
            "- `listDelegatesForPhysician(physicianUserId: string)` — list active delegates with user info (name, email, last login).",
            "- `listPhysiciansForDelegate(delegateUserId: string)` — list physicians the delegate serves, with permissions per physician.",
            "- `updateLinkagePermissions(linkageId: string, permissions: string[], canApproveBatches: boolean)` — update permissions JSONB.",
            "- `deactivateLinkage(linkageId: string)` — set is_active = false."
          ],
          "security": [
            "UNIQUE constraint on (physician_user_id, delegate_user_id) prevents duplicate linkages.",
            "listDelegatesForPhysician only returns delegates for the specified physician — physician-scoped.",
            "Deactivating a linkage must also trigger session revocation for the delegate's sessions in this physician context (handled by service layer)."
          ],
          "tests": [
            "createDelegateLinkage creates active linkage",
            "createDelegateLinkage rejects duplicate physician-delegate pair",
            "listDelegatesForPhysician returns only this physician's delegates",
            "listPhysiciansForDelegate returns only this delegate's physicians",
            "updateLinkagePermissions replaces permission set",
            "deactivateLinkage sets is_active false",
            "findLinkage returns null for inactive linkage"
          ]
        },
        {
          "id": "D01-014",
          "description": "Repository: audit log (append-only)",
          "verify": "pnpm --filter api vitest run src/domains/iam/iam.test.ts",
          "depends": ["D01-007"],
          "build": [
            "Add to `apps/api/src/domains/iam/iam.repository.ts`:",
            "",
            "- `appendAuditLog(entry: AuditLogEntry)` — insert a single audit entry. This is the ONLY write operation on the audit_log table.",
            "- `queryAuditLog(userId: string, filters: AuditLogFilters)` — paginated query filtered by action, category, date range. Returns in reverse chronological order. Max 200 per page.",
            "- `querySystemAuditLog(filters: AuditLogFilters)` — admin-only: query across all users.",
            "- `exportAuditLog(userId: string, filters: AuditLogFilters)` — return all matching entries as an array for CSV export (no pagination limit, but date range required).",
            "",
            "**CRITICAL: Do NOT create update or delete functions for audit_log. The table is append-only.**"
          ],
          "security": [
            "Audit log is append-only. No update, no delete. This is a hard requirement.",
            "queryAuditLog scopes to the specified userId — a physician can only see their own audit trail.",
            "querySystemAuditLog is for admin role only. The route guard (not the repository) enforces this.",
            "The audit log repository itself logs audit.queried when queryAuditLog is called (via the service layer).",
            "JSONB detail field must be sanitised before storage: no plaintext passwords, tokens, or TOTP secrets."
          ],
          "tests": [
            "appendAuditLog inserts entry with correct fields",
            "queryAuditLog returns only entries for specified user",
            "queryAuditLog respects date range filter",
            "queryAuditLog respects action filter",
            "queryAuditLog paginates correctly (50 default, max 200)",
            "queryAuditLog returns reverse chronological order",
            "exportAuditLog requires date range",
            "audit_log has no update function",
            "audit_log has no delete function"
          ]
        }
      ]
    },
    {
      "title": "Domain 1: Identity & Access — Service Layer",
      "tasks": [
        {
          "id": "D01-020",
          "description": "Service: registration and email verification",
          "verify": "pnpm --filter api vitest run src/domains/iam/iam.test.ts",
          "depends": ["D01-010"],
          "build": [
            "Create `apps/api/src/domains/iam/iam.service.ts` with registration functions:",
            "",
            "- `registerUser(data: RegisterInput)` — hash password with Argon2id, create user, generate email verification token, emit auth.registered audit event, emit USER_REGISTERED event for notification service. Return user_id.",
            "- `verifyEmail(token: string)` — validate token, set email_verified = true, emit auth.email_verified audit event. Return { mfa_setup_required: true }.",
            "",
            "**Password hashing:** Use @node-rs/argon2 with parameters from CLAUDE.md (memory 19456, iterations 2, parallelism 1).",
            "**Email verification token:** Generate UUID, store SHA-256 hash in a verification_tokens record (or reuse invitation_tokens with a type field). Token expires after 24 hours.",
            "**Anti-enumeration:** Registration always succeeds from the client's perspective. If email exists, send a 'someone tried to register with your email' notification instead of an error."
          ],
          "security": [
            "Anti-enumeration: never reveal whether an email is already registered. Return the same response regardless.",
            "Password is hashed before any database write. Plaintext password must not appear in logs or error messages.",
            "Email verification token is stored as SHA-256 hash, not plaintext."
          ],
          "tests": [
            "registerUser hashes password with Argon2id",
            "registerUser normalises email to lowercase",
            "registerUser emits audit event",
            "registerUser with existing email does not reveal email exists",
            "verifyEmail with valid token sets email_verified true",
            "verifyEmail with expired token returns error",
            "verifyEmail with invalid token returns error"
          ]
        },
        {
          "id": "D01-021",
          "description": "Service: MFA setup and recovery codes",
          "verify": "pnpm --filter api vitest run src/domains/iam/iam.test.ts",
          "depends": ["D01-010", "D01-012"],
          "build": [
            "Add to `apps/api/src/domains/iam/iam.service.ts`:",
            "",
            "- `initiateMfaSetup(userId: string)` — generate TOTP secret, encrypt with AES-256-GCM, store encrypted secret. Return { qr_code_uri, manual_key } for the user to scan.",
            "- `confirmMfaSetup(userId: string, totpCode: string)` — verify TOTP code against stored secret. If valid: set mfa_configured = true, generate 10 recovery codes, hash each with Argon2id, store hashes, return plaintext codes (shown once). Emit auth.mfa_setup audit event.",
            "- `regenerateRecoveryCodes(userId: string, totpCode: string)` — verify current TOTP first. Generate new 10 codes, replace old ones. Emit account.recovery_codes_regenerated. Return plaintext codes.",
            "- `reconfigureMfa(userId: string, currentTotpCode: string)` — verify current TOTP. Generate new secret and QR. Emit account.mfa_reconfigured.",
            "",
            "**TOTP library:** Use otplib. Issuer: 'Meritum'. Algorithm: SHA1. Digits: 6. Period: 30 seconds.",
            "**Recovery code format:** 10 codes, each 8 alphanumeric characters, grouped as XXXX-XXXX for readability.",
            "**Encryption:** Use crypto.createCipheriv with AES-256-GCM. Key from TOTP_ENCRYPTION_KEY env var."
          ],
          "security": [
            "TOTP secret is encrypted at rest with AES-256-GCM. Encryption key is from environment variable, never in database.",
            "Recovery codes are shown exactly once (at generation). Only Argon2id hashes are stored.",
            "MFA reconfiguration requires current TOTP code to prevent an attacker with session access from disabling MFA."
          ],
          "tests": [
            "initiateMfaSetup generates and encrypts TOTP secret",
            "confirmMfaSetup accepts valid TOTP code",
            "confirmMfaSetup rejects invalid TOTP code",
            "confirmMfaSetup generates 10 recovery codes",
            "confirmMfaSetup stores hashed (not plaintext) recovery codes",
            "regenerateRecoveryCodes requires valid current TOTP",
            "regenerateRecoveryCodes replaces old codes",
            "reconfigureMfa requires valid current TOTP"
          ]
        },
        {
          "id": "D01-022",
          "description": "Service: login flow (password + MFA + session creation)",
          "verify": "pnpm --filter api vitest run src/domains/iam/iam.test.ts",
          "depends": ["D01-010", "D01-011", "D01-012"],
          "build": [
            "Add to `apps/api/src/domains/iam/iam.service.ts`:",
            "",
            "- `loginStep1(email: string, password: string, ipAddress: string)` — find user by email. Verify password with Argon2id. Check account not locked. If valid: generate MFA session token (short-lived, 5 min), emit auth.login_success audit event, return { mfa_required: true, mfa_session_token }. If invalid: increment failed login, emit auth.login_failed, return generic error.",
            "- `loginStep2Mfa(mfaSessionToken: string, totpCode: string, ipAddress: string, userAgent: string)` — validate MFA session token, verify TOTP code. If valid: create session, generate session token, reset failed login count. Return session token (to be set as cookie by handler).",
            "- `loginStep2Recovery(mfaSessionToken: string, recoveryCode: string, ipAddress: string, userAgent: string)` — validate MFA session token, compare recovery code against all unused hashes. If match: mark used, create session, emit auth.login_recovery_used. Return session token + remaining_codes count.",
            "",
            "**MFA session token:** Short-lived JWT (5 min expiry) containing user_id. Signs with SESSION_SECRET. Only used to bridge the two login steps.",
            "**Session token:** Generate 32 random bytes, hex-encode. Store SHA-256 hash in sessions table. Set as HTTP-only cookie.",
            "**Anti-enumeration:** Same error message for wrong email and wrong password ('Invalid credentials')."
          ],
          "security": [
            "Anti-enumeration: 'Invalid credentials' for both wrong email and wrong password. Same response time (use constant-time comparison even when user not found).",
            "Account lockout: 10 failed attempts → 30 minute lock. Failed MFA attempts also count.",
            "MFA session token expires after 5 minutes — prevents indefinite MFA bypass window.",
            "Session token: 32 random bytes. Only SHA-256 hash stored in DB. Plaintext only in cookie.",
            "Recovery code comparison: load all unused hashes, Argon2id verify each. This is intentionally slow for security."
          ],
          "tests": [
            "loginStep1 with valid credentials returns mfa_session_token",
            "loginStep1 with wrong password returns generic error",
            "loginStep1 with non-existent email returns same generic error",
            "loginStep1 with locked account returns locked error",
            "loginStep1 increments failed count on failure",
            "loginStep2Mfa with valid TOTP creates session",
            "loginStep2Mfa with invalid TOTP returns error",
            "loginStep2Mfa with expired mfa_session_token returns error",
            "loginStep2Recovery with valid recovery code creates session",
            "loginStep2Recovery marks code as used",
            "loginStep2Recovery returns remaining code count"
          ]
        },
        {
          "id": "D01-023",
          "description": "Service: session management and password reset",
          "verify": "pnpm --filter api vitest run src/domains/iam/iam.test.ts",
          "depends": ["D01-011"],
          "build": [
            "Add to `apps/api/src/domains/iam/iam.service.ts`:",
            "",
            "**Session management:**",
            "- `validateSession(tokenHash: string)` — find session, check expiry, refresh idle timer. Return AuthContext object or null.",
            "- `listSessions(userId: string)` — return active sessions (id, ip, user_agent, created_at, last_active_at).",
            "- `revokeSession(userId: string, sessionId: string)` — revoke specific session. Verify it belongs to userId. Emit auth.session_revoked.",
            "- `revokeAllSessions(userId: string, currentSessionId: string)` — revoke all except current. Emit auth.session_revoked_all.",
            "- `logout(sessionId: string)` — revoke with reason 'logout'. Emit auth.logout.",
            "",
            "**Password reset:**",
            "- `requestPasswordReset(email: string)` — always return success (anti-enumeration). If user exists: generate reset token (UUID), store SHA-256 hash with 1-hour expiry, emit USER_PASSWORD_RESET_REQUESTED event for notification.",
            "- `resetPassword(token: string, newPassword: string)` — verify token hash, check expiry. Hash new password. Update user. Invalidate ALL sessions (force re-login). Emit auth.password_reset_completed."
          ],
          "security": [
            "validateSession must check BOTH absolute expiry (24h) and idle expiry (60min). Either exceeded → session invalid.",
            "revokeSession must verify the session belongs to the requesting userId — no cross-user session revocation.",
            "requestPasswordReset: anti-enumeration. Same response whether email exists or not. Same response time.",
            "resetPassword invalidates ALL sessions — attacker with stolen session is forced out when password changes."
          ],
          "tests": [
            "validateSession returns AuthContext for valid session",
            "validateSession returns null for expired session (absolute)",
            "validateSession returns null for expired session (idle)",
            "validateSession refreshes idle timer on success",
            "revokeSession revokes session belonging to user",
            "revokeSession rejects session belonging to different user",
            "revokeAllSessions keeps current session active",
            "requestPasswordReset always returns success",
            "resetPassword with valid token updates password",
            "resetPassword invalidates all sessions",
            "resetPassword with expired token returns error"
          ]
        },
        {
          "id": "D01-024",
          "description": "Service: delegate management",
          "verify": "pnpm --filter api vitest run src/domains/iam/iam.test.ts",
          "depends": ["D01-012", "D01-013"],
          "build": [
            "Add to `apps/api/src/domains/iam/iam.service.ts`:",
            "",
            "- `inviteDelegate(physicianUserId: string, email: string, permissions: string[])` — validate permissions are a subset of allowed delegate permissions. Generate invitation token. Store hash. Send DELEGATE_INVITED event for notification. Emit delegate.invited audit.",
            "- `acceptInvitation(token: string, registrationData?: { fullName, password })` — verify invitation token. If delegate email matches existing user: create linkage. If new user: create account + linkage. Emit delegate.accepted. Return linkage_id.",
            "- `listDelegates(physicianUserId: string)` — return delegates with permissions, last login, active status.",
            "- `updateDelegatePermissions(physicianUserId: string, linkageId: string, permissions: string[], canApproveBatches: boolean)` — verify linkage belongs to physician. Update. Emit delegate.permissions_updated.",
            "- `revokeDelegate(physicianUserId: string, linkageId: string)` — deactivate linkage. Revoke delegate's sessions for this physician context. Emit delegate.revoked.",
            "- `listPhysiciansForDelegate(delegateUserId: string)` — return physician list with permissions per physician.",
            "- `switchPhysicianContext(delegateUserId: string, physicianUserId: string)` — verify active linkage exists. Return updated AuthContext with delegateContext populated. Emit delegate.context_switched."
          ],
          "security": [
            "Delegate permissions must be validated against the allowed set — delegates cannot be granted DELEGATE_MANAGE, SUBSCRIPTION_MANAGE, or DATA_EXPORT.",
            "Revoking a delegate must immediately invalidate their sessions for this physician context.",
            "switchPhysicianContext must verify an active linkage exists — delegate cannot access an unlinked physician.",
            "Invitation token is hashed before storage. Plaintext only in email."
          ],
          "tests": [
            "inviteDelegate generates invitation and emits event",
            "inviteDelegate rejects invalid permissions",
            "acceptInvitation creates linkage for existing user",
            "acceptInvitation creates new user account for new delegate",
            "acceptInvitation rejects expired invitation",
            "acceptInvitation rejects already-accepted invitation",
            "updateDelegatePermissions rejects if linkage belongs to different physician",
            "revokeDelegate deactivates linkage",
            "revokeDelegate revokes delegate sessions",
            "switchPhysicianContext succeeds with active linkage",
            "switchPhysicianContext fails without active linkage"
          ]
        },
        {
          "id": "D01-025",
          "description": "Service: account management and deletion",
          "verify": "pnpm --filter api vitest run src/domains/iam/iam.test.ts",
          "depends": ["D01-010", "D01-013"],
          "build": [
            "Add to `apps/api/src/domains/iam/iam.service.ts`:",
            "",
            "- `getAccount(userId: string)` — return account info (name, email, role, subscription_status, mfa_configured).",
            "- `updateAccount(userId: string, data: AccountUpdateInput)` — update name, phone. Email change is not supported via this endpoint (requires re-verification flow, deferred).",
            "- `requestAccountDeletion(userId: string, password: string, totpCode: string, confirmation: string)` — verify password, verify TOTP, verify confirmation === 'DELETE'. Cancel Stripe subscription. Invalidate all sessions. Deactivate all delegate linkages (notify delegates). Schedule data deletion in 30 days. Emit account.deletion_requested.",
            "- `checkSubscriptionAccess(userId: string)` — return subscription status and access level (full, read_only, suspended). Used by auth middleware."
          ],
          "security": [
            "Account deletion requires three-factor confirmation: password + TOTP + typed 'DELETE'.",
            "Deletion is soft for 30 days (grace period). Data portability export must be available during grace period.",
            "All delegate linkages deactivated on deletion — delegates lose access immediately.",
            "Subscription cancellation via Stripe must happen synchronously before marking deletion."
          ],
          "tests": [
            "getAccount returns account info without sensitive fields",
            "updateAccount updates name and phone",
            "updateAccount does not update email or password",
            "requestAccountDeletion requires correct password",
            "requestAccountDeletion requires valid TOTP",
            "requestAccountDeletion requires 'DELETE' confirmation",
            "requestAccountDeletion invalidates all sessions",
            "requestAccountDeletion deactivates delegate linkages",
            "requestAccountDeletion schedules deletion in 30 days",
            "checkSubscriptionAccess returns correct access level for each status"
          ]
        }
      ]
    },
    {
      "title": "Domain 1: Identity & Access — Middleware & Routes",
      "tasks": [
        {
          "id": "D01-030",
          "description": "Auth middleware: authenticate, authorize, checkSubscription, auditLog plugins",
          "verify": "pnpm --filter api vitest run src/domains/iam/iam.test.ts",
          "depends": ["D01-023"],
          "build": [
            "Create `apps/api/src/plugins/auth.plugin.ts` as a Fastify plugin that decorates requests with auth context:",
            "",
            "**authenticate(request, reply):**",
            "- Extract session token from HTTP-only cookie",
            "- SHA-256 hash the token",
            "- Call validateSession to check expiry and get user data",
            "- If invalid: reply 401",
            "- If valid: populate request.authContext with AuthContext object",
            "",
            "**authorize(...requiredPermissions: string[]):**",
            "- Returns a preHandler function",
            "- If role is physician: all permissions granted (pass)",
            "- If role is delegate: check delegateContext.permissions includes all required permissions",
            "- If role is admin: all permissions granted",
            "- If insufficient: reply 403",
            "",
            "**checkSubscription(...allowedStatuses: string[]):**",
            "- Returns a preHandler function",
            "- Check request.authContext.subscriptionStatus is in allowedStatuses",
            "- If suspended: return 402 with ACCOUNT_SUSPENDED",
            "- If cancelled: return 402 with SUBSCRIPTION_REQUIRED",
            "",
            "**auditLog plugin:**",
            "- Fastify onResponse hook that logs every request: userId, action (derived from route), ip, user_agent",
            "- Only logs state-changing requests (POST, PUT, PATCH, DELETE) by default",
            "- Configurable per route via route metadata",
            "",
            "Also create `apps/api/src/plugins/rate-limit.plugin.ts`:",
            "- Use @fastify/rate-limit",
            "- Default: 100 req/min per user",
            "- Auth endpoints: 10 req/min per IP",
            "- File uploads: 5 req/min per user"
          ],
          "security": [
            "Session token extracted from cookie only (never from Authorization header or query parameter).",
            "authorize must handle missing delegateContext gracefully (delegate without active physician context gets 403).",
            "Rate limiting on auth endpoints is per-IP, not per-user (unauthenticated requests).",
            "Audit log hook must not log sensitive request body fields (password, totp_code, recovery_code)."
          ],
          "tests": [
            "authenticate rejects request without cookie",
            "authenticate rejects request with invalid token",
            "authenticate populates authContext on valid session",
            "authorize allows physician for any permission",
            "authorize allows delegate with matching permission",
            "authorize rejects delegate without matching permission",
            "checkSubscription allows active status",
            "checkSubscription returns 402 for suspended",
            "rate limiting blocks after threshold exceeded"
          ]
        },
        {
          "id": "D01-031",
          "description": "Routes: authentication endpoints (register, login, MFA, password reset)",
          "verify": "pnpm --filter api vitest run test/integration/iam/",
          "depends": ["D01-020", "D01-021", "D01-022", "D01-023", "D01-030"],
          "build": [
            "Create `apps/api/src/domains/iam/iam.routes.ts` and `apps/api/src/domains/iam/iam.handlers.ts`.",
            "",
            "**Auth routes (no auth required):**",
            "- POST /api/v1/auth/register → registerHandler (body: registerSchema)",
            "- POST /api/v1/auth/verify-email → verifyEmailHandler (body: verifyEmailSchema)",
            "- POST /api/v1/auth/login → loginStep1Handler (body: loginSchema)",
            "- POST /api/v1/auth/login/mfa → loginStep2MfaHandler (body: loginMfaSchema)",
            "- POST /api/v1/auth/login/recovery → loginStep2RecoveryHandler (body: loginRecoverySchema)",
            "- POST /api/v1/auth/password/reset-request → passwordResetRequestHandler (body: passwordResetRequestSchema)",
            "- POST /api/v1/auth/password/reset → passwordResetHandler (body: passwordResetSchema)",
            "",
            "**Auth routes (auth required):**",
            "- POST /api/v1/auth/mfa/setup → mfaSetupHandler (requires email-verified session)",
            "- POST /api/v1/auth/mfa/confirm → mfaConfirmHandler (body: mfaConfirmSchema)",
            "- POST /api/v1/auth/logout → logoutHandler",
            "",
            "**Handlers are thin:** validate input (via Zod schema on route), call service function, format response.",
            "",
            "Also create `apps/api/test/integration/iam/auth.integration.ts` with full request/response integration tests."
          ],
          "security": [
            "Login handlers set session cookie: HttpOnly, Secure, SameSite=Lax, Path=/, maxAge=86400.",
            "Logout handler clears the cookie.",
            "All auth endpoints rate-limited at 10 req/min per IP.",
            "Registration and password reset always return 200 (anti-enumeration)."
          ],
          "tests": [
            "POST /auth/register with valid data returns 201",
            "POST /auth/register with invalid email returns 400",
            "POST /auth/register with weak password returns 400",
            "POST /auth/login with valid credentials returns mfa_session_token",
            "POST /auth/login/mfa with valid TOTP sets session cookie",
            "POST /auth/login/recovery with valid code sets session cookie",
            "POST /auth/logout clears session cookie",
            "POST /auth/password/reset-request always returns 200"
          ]
        },
        {
          "id": "D01-032",
          "description": "Routes: session, delegate, and account endpoints",
          "verify": "pnpm --filter api vitest run test/integration/iam/",
          "depends": ["D01-023", "D01-024", "D01-025", "D01-030"],
          "build": [
            "Add to `apps/api/src/domains/iam/iam.routes.ts` and handlers:",
            "",
            "**Session routes (auth required):**",
            "- GET /api/v1/sessions → listSessionsHandler",
            "- DELETE /api/v1/sessions/:id → revokeSessionHandler (params: sessionIdParamSchema)",
            "- DELETE /api/v1/sessions → revokeAllSessionsHandler",
            "",
            "**Delegate routes (auth required, physician role):**",
            "- POST /api/v1/delegates/invite → inviteHandler (body: delegateInviteSchema)",
            "- GET /api/v1/delegates → listDelegatesHandler",
            "- PATCH /api/v1/delegates/:id/permissions → updatePermissionsHandler (body: delegateUpdatePermissionsSchema)",
            "- DELETE /api/v1/delegates/:id → revokeHandler",
            "- POST /api/v1/delegates/accept → acceptHandler (body: delegateAcceptSchema, no auth required)",
            "- GET /api/v1/delegates/physicians → listPhysiciansHandler (delegate role)",
            "",
            "**Account routes (auth required):**",
            "- GET /api/v1/account → getAccountHandler",
            "- PATCH /api/v1/account → updateAccountHandler (body: accountUpdateSchema)",
            "- POST /api/v1/account/mfa/regenerate-codes → regenerateCodesHandler (body: mfaConfirmSchema)",
            "- POST /api/v1/account/mfa/reconfigure → reconfigureMfaHandler (body: mfaReconfigureSchema)",
            "- POST /api/v1/account/delete → deleteAccountHandler (body: accountDeleteSchema)",
            "- GET /api/v1/account/audit-log → auditLogHandler (query: auditLogQuerySchema)",
            "",
            "Create `apps/api/test/integration/iam/sessions.integration.ts`, `delegates.integration.ts`, and `account.integration.ts`."
          ],
          "security": [
            "Delegate management routes require physician role (except /delegates/accept and /delegates/physicians).",
            "/delegates/physicians requires delegate role.",
            "Account delete route requires physician role (delegates cannot delete physician accounts).",
            "Audit log route requires physician or admin role."
          ],
          "tests": [
            "GET /sessions returns active sessions for authenticated user",
            "DELETE /sessions/:id revokes specific session",
            "POST /delegates/invite creates invitation",
            "POST /delegates/invite as delegate returns 403",
            "POST /delegates/accept with valid token creates linkage",
            "GET /delegates/physicians returns linked physicians for delegate",
            "PATCH /delegates/:id/permissions updates permissions",
            "DELETE /delegates/:id revokes delegate",
            "GET /account returns account info",
            "POST /account/delete with valid 3-factor confirmation succeeds",
            "GET /account/audit-log returns paginated log"
          ]
        }
      ]
    },
    {
      "title": "Domain 1: Identity & Access — Security Tests",
      "tasks": [
        {
          "id": "D01-040",
          "description": "Security: authentication enforcement on every route",
          "verify": "pnpm --filter api vitest run test/security/iam/iam.authn.security.ts",
          "depends": ["D01-031", "D01-032"],
          "build": [
            "Create `apps/api/test/security/iam/iam.authn.security.ts`.",
            "",
            "Test every authenticated route in the IAM domain returns 401 without a valid session cookie. This includes:",
            "",
            "- POST /api/v1/auth/mfa/setup",
            "- POST /api/v1/auth/mfa/confirm",
            "- POST /api/v1/auth/logout",
            "- GET /api/v1/sessions",
            "- DELETE /api/v1/sessions/:id",
            "- DELETE /api/v1/sessions",
            "- POST /api/v1/delegates/invite",
            "- GET /api/v1/delegates",
            "- PATCH /api/v1/delegates/:id/permissions",
            "- DELETE /api/v1/delegates/:id",
            "- GET /api/v1/delegates/physicians",
            "- GET /api/v1/account",
            "- PATCH /api/v1/account",
            "- POST /api/v1/account/mfa/regenerate-codes",
            "- POST /api/v1/account/mfa/reconfigure",
            "- POST /api/v1/account/delete",
            "- GET /api/v1/account/audit-log",
            "",
            "For each route: send request with no cookie, with expired cookie, and with tampered cookie. All must return 401 with no data leakage in the response body."
          ],
          "security": [
            "401 responses must not contain any data in the response body beyond the error object.",
            "Tampered cookies must be rejected (invalid signature / hash mismatch).",
            "Expired sessions must return 401 (not 200 with stale data)."
          ]
        },
        {
          "id": "D01-041",
          "description": "Security: authorization and role enforcement",
          "verify": "pnpm --filter api vitest run test/security/iam/iam.authz.security.ts",
          "depends": ["D01-031", "D01-032"],
          "build": [
            "Create `apps/api/test/security/iam/iam.authz.security.ts`.",
            "",
            "Test role-based access control:",
            "",
            "**Delegate cannot access physician-only routes:**",
            "- POST /delegates/invite as delegate → 403",
            "- PATCH /delegates/:id/permissions as delegate → 403",
            "- DELETE /delegates/:id as delegate → 403",
            "- POST /account/delete as delegate → 403",
            "",
            "**Physician cannot access delegate-only routes:**",
            "- GET /delegates/physicians as physician → 403 (or empty, depending on design)",
            "",
            "**Delegate permission boundary tests:**",
            "- Create delegate with CLAIM_VIEW only. Verify delegate cannot access routes requiring CLAIM_CREATE.",
            "- Create delegate with no AUDIT_VIEW. Verify delegate cannot access /account/audit-log.",
            "",
            "**Permission escalation prevention:**",
            "- Delegate cannot call PATCH /delegates/:id/permissions to modify their own permissions.",
            "- Delegate cannot call POST /delegates/invite to create other delegates."
          ]
        },
        {
          "id": "D01-042",
          "description": "Security: cross-user isolation (tenant scoping)",
          "verify": "pnpm --filter api vitest run test/security/iam/iam.scoping.security.ts",
          "depends": ["D01-031", "D01-032"],
          "build": [
            "Create `apps/api/test/security/iam/iam.scoping.security.ts`.",
            "",
            "Create two physician accounts (physician1, physician2) using createSecurityPair fixture.",
            "",
            "**Session isolation:**",
            "- Physician1 cannot see physician2's sessions via GET /sessions",
            "- Physician1 cannot revoke physician2's session via DELETE /sessions/:id → 404",
            "",
            "**Delegate isolation:**",
            "- Physician1 cannot see physician2's delegates via GET /delegates",
            "- Physician1 cannot modify physician2's delegate via PATCH /delegates/:id/permissions → 404",
            "- Physician1 cannot revoke physician2's delegate via DELETE /delegates/:id → 404",
            "",
            "**Audit log isolation:**",
            "- Physician1's audit log query never returns physician2's entries",
            "",
            "**Delegate cross-context isolation:**",
            "- Create delegate linked to physician1 only",
            "- Delegate cannot switch to physician2 context (no active linkage) → 403",
            "- If delegate is linked to both: data in physician1 context does not leak into physician2 context",
            "",
            "**Important:** All cross-user access attempts return 404, not 403 (do not confirm resource existence)."
          ]
        },
        {
          "id": "D01-043",
          "description": "Security: input validation and injection prevention",
          "verify": "pnpm --filter api vitest run test/security/iam/iam.input.security.ts",
          "depends": ["D01-031", "D01-032"],
          "build": [
            "Create `apps/api/test/security/iam/iam.input.security.ts`.",
            "",
            "**SQL injection payloads on all string inputs:**",
            "- email field: `' OR 1=1--`, `'; DROP TABLE users;--`",
            "- full_name field: SQL injection payloads",
            "- password field: SQL injection payloads (must be accepted as valid password if meeting requirements, but parameterised queries prevent injection)",
            "",
            "**XSS payloads on all stored text fields:**",
            "- full_name: `<script>alert(1)</script>`",
            "- phone: `<img onerror=alert(1) src=x>`",
            "",
            "**Type coercion attacks:**",
            "- Send number where string expected, array where string expected, null where required",
            "- Send negative page_size to audit log query",
            "- Send page_size > 200 to audit log query (should cap at 200)",
            "",
            "**Password validation:**",
            "- Password with 11 characters (below minimum 12) → 400",
            "- Password without uppercase → 400",
            "- Password without digit → 400",
            "- Password without special character → 400",
            "",
            "**UUID parameter validation:**",
            "- Non-UUID in path params (e.g., DELETE /sessions/not-a-uuid) → 400",
            "",
            "**TOTP validation:**",
            "- TOTP code with letters → 400",
            "- TOTP code with 5 digits → 400",
            "- TOTP code with 7 digits → 400"
          ]
        },
        {
          "id": "D01-044",
          "description": "Security: data leakage prevention and anti-enumeration",
          "verify": "pnpm --filter api vitest run test/security/iam/iam.leakage.security.ts",
          "depends": ["D01-031", "D01-032"],
          "build": [
            "Create `apps/api/test/security/iam/iam.leakage.security.ts`.",
            "",
            "**Anti-enumeration tests:**",
            "- POST /auth/register with existing email returns same 200 as new email",
            "- POST /auth/password/reset-request with non-existent email returns same 200 as existing email",
            "- POST /auth/login with non-existent email returns same error as wrong password (no timing difference measurable in integration test)",
            "",
            "**Error response sanitisation:**",
            "- 401 response body contains only error object, no user data",
            "- 403 response body does not reveal what permission is missing (generic 'Insufficient permissions')",
            "- 404 response for cross-user resource does not confirm resource exists",
            "- 500 error does not expose stack traces, SQL errors, or internal details",
            "",
            "**Header checks:**",
            "- No X-Powered-By header",
            "- No Server header revealing version",
            "- HSTS header present",
            "- CSP headers present",
            "",
            "**Sensitive data not in responses:**",
            "- GET /account does not return password_hash",
            "- GET /account does not return totp_secret_encrypted",
            "- GET /delegates does not return delegate's password_hash",
            "- Audit log entries do not contain plaintext passwords or tokens"
          ]
        },
        {
          "id": "D01-045",
          "description": "Security: audit trail completeness",
          "verify": "pnpm --filter api vitest run test/security/iam/iam.audit.security.ts",
          "depends": ["D01-031", "D01-032"],
          "build": [
            "Create `apps/api/test/security/iam/iam.audit.security.ts`.",
            "",
            "Verify that each security-relevant action produces an audit record. Run the action, then query the audit log and verify the entry exists with correct fields.",
            "",
            "**Authentication events:**",
            "- Successful login → auth.login_success with ip_address",
            "- Failed login → auth.login_failed with ip_address",
            "- MFA success → auth.login_mfa_success",
            "- Recovery code used → auth.login_recovery_used with remaining count",
            "- Logout → auth.logout",
            "- Session revoked → auth.session_revoked",
            "",
            "**Delegate events:**",
            "- Delegate invited → delegate.invited with delegate_email",
            "- Invitation accepted → delegate.accepted",
            "- Permissions updated → delegate.permissions_updated with old and new permissions",
            "- Delegate revoked → delegate.revoked",
            "",
            "**Account events:**",
            "- Account updated → account.updated with changed fields",
            "- MFA reconfigured → account.mfa_reconfigured",
            "- Recovery codes regenerated → account.recovery_codes_regenerated",
            "- Account deletion requested → account.deletion_requested",
            "",
            "**Audit log integrity:**",
            "- Verify no UPDATE endpoints exist for audit_log",
            "- Verify no DELETE endpoints exist for audit_log",
            "- Verify querying the audit log produces audit.queried entry"
          ]
        }
      ]
    },
    {
      "title": "Domain 1: Identity & Access — Final Validation",
      "tasks": [
        {
          "id": "D01-099",
          "description": "Full domain test suite: all unit + integration + security tests",
          "verify": "pnpm --filter api vitest run src/domains/iam/ test/integration/iam/ test/security/iam/",
          "depends": ["D01-040", "D01-041", "D01-042", "D01-043", "D01-044", "D01-045"],
          "build": [
            "Run the complete test suite for Domain 1 Identity & Access. Do NOT write new code unless tests fail.",
            "",
            "1. Run all unit tests: `pnpm --filter api vitest run src/domains/iam/`",
            "2. Run all integration tests: `pnpm --filter api vitest run test/integration/iam/`",
            "3. Run all security tests: `pnpm --filter api vitest run test/security/iam/`",
            "",
            "If any tests fail: read the failure, fix the source code (not the tests unless the test is wrong), re-run.",
            "",
            "After all pass, run the full suite one final time:",
            "```bash",
            "pnpm --filter api vitest run src/domains/iam/ test/integration/iam/ test/security/iam/",
            "```",
            "",
            "Verify these security test files exist and are non-empty:",
            "- test/security/iam/iam.authn.security.ts",
            "- test/security/iam/iam.authz.security.ts",
            "- test/security/iam/iam.scoping.security.ts",
            "- test/security/iam/iam.input.security.ts",
            "- test/security/iam/iam.leakage.security.ts",
            "- test/security/iam/iam.audit.security.ts"
          ]
        }
      ]
    }
  ]
}
