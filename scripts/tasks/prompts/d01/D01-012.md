# Task D01-012: Repository: recovery codes and invitation tokens

## What to Build

Add to `apps/api/src/domains/iam/iam.repository.ts`:

**Recovery codes:**
- `createRecoveryCodes(userId: string, codeHashes: string[])` — bulk insert 10 hashed codes. Delete any existing unused codes for this user first.
- `findUnusedRecoveryCode(userId: string)` — return all unused codes for Argon2id comparison in service layer.
- `markRecoveryCodeUsed(codeId: string)` — set used = true.
- `countRemainingCodes(userId: string)` — count unused codes.

**Invitation tokens:**
- `createInvitation(data: { physicianUserId, delegateEmail, tokenHash, permissions, expiresAt })` — insert invitation.
- `findInvitationByTokenHash(tokenHash: string)` — find non-accepted, non-expired invitation.
- `markInvitationAccepted(invitationId: string)` — set accepted = true.
- `listPendingInvitations(physicianUserId: string)` — list non-accepted, non-expired invitations.

## Critical Security Rules

- Recovery codes are Argon2id hashed. Comparison happens in the service layer by loading all unused hashes and comparing one by one (constant-time per comparison).
- createRecoveryCodes deletes existing unused codes first — regeneration invalidates all previous codes.
- findInvitationByTokenHash must check both accepted = false AND expires_at > now().

## Prerequisites

This task depends on the following completed tasks: D01-007

## Tests to Write

```typescript
  it('createRecoveryCodes inserts 10 codes');
  it('createRecoveryCodes deletes previous unused codes');
  it('markRecoveryCodeUsed sets used flag');
  it('countRemainingCodes returns correct count');
  it('createInvitation stores invitation with hashed token');
  it('findInvitationByTokenHash returns null for accepted invitation');
  it('findInvitationByTokenHash returns null for expired invitation');
  it('listPendingInvitations excludes accepted and expired');
```

## Run After Completion

```bash
pnpm --filter api vitest run src/domains/iam/iam.test.ts
```

All tests must pass before outputting [TASK_COMPLETE].