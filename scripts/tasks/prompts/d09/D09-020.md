# Task D09-020: Service â€” event processing pipeline (receive, resolve recipients, check preferences, render, create)

## What to Build

Create `apps/api/src/domains/notification/notification.service.ts` with the event processing pipeline:

- `processEvent(event: { eventType: string, physicianId: string, metadata?: Record<string, unknown> })` -- main pipeline entry point. Orchestrates all steps below. Emit notification.event_emitted audit event.

**Step 1 -- Recipient resolution:**
- `resolveRecipients(physicianId: string, eventType: string)` -- primary recipient: the physician's user_id. Secondary: active delegates linked to this physician whose permissions include the relevant capability for this event type. Uses permission-to-event mapping (e.g., CLAIM_VIEW permission -> receives claim events). Return array of `{ userId: string, isDelegate: boolean, physicianContextId: string | null }`.

The permission-to-event mapping should be defined as a frozen object:
- CLAIM_VIEW: receives CLAIM_VALIDATED, CLAIM_FLAGGED, CLAIM_ASSESSED, CLAIM_REJECTED, CLAIM_PAID, DUPLICATE_DETECTED
- CLAIM_SUBMIT: receives BATCH_ASSEMBLED, BATCH_SUBMITTED, BATCH_ERROR
- CLAIM_MANAGE: receives DEADLINE_7_DAY, DEADLINE_3_DAY, DEADLINE_1_DAY, DEADLINE_EXPIRED
- AI_VIEW: receives AI_SUGGESTION_READY, AI_HIGH_VALUE_SUGGESTION, SOMB_CHANGE_IMPACT
- DELEGATE_MANAGE: receives DELEGATE_INVITED, DELEGATE_ACCEPTED, DELEGATE_REVOKED
- ANALYTICS_VIEW: receives REPORT_READY, DATA_EXPORT_READY

Physician always receives all events. Delegates only receive events matching their permissions.

**Step 2 -- Preference check (per recipient):**
- `checkPreferences(recipientProviderId: string, eventType: string)` -- look up preferences for event category. Return `{ inAppEnabled: boolean, emailEnabled: boolean, digestMode: DigestMode }`. For URGENT events: in_app always true regardless of preference.

If no preference exists for the category, use defaults from EVENT_CATALOGUE.

**Step 3 -- Template rendering:**
- `renderNotification(templateId: string, variables: Record<string, unknown>)` -- load template by event_type. Substitute {{variables}} in title, body, email subject/body, and action_url_template. Escape all variable values to prevent template injection. Return rendered content.

The variable substitution should:
1. Find all `{{variableName}}` patterns in each template string
2. Replace with the corresponding value from the variables object
3. HTML-escape all variable values before substitution (convert `<`, `>`, `&`, `"`, `'` to entities)
4. Throw an error if a required variable is missing from the variables object

**Step 4 -- Notification creation (per recipient):**
- Create notification record via repository. Set channels_delivered based on preference check results.
- If email enabled and digest mode IMMEDIATE: queue for email delivery.
- If email enabled and digest mode DAILY_DIGEST or WEEKLY_DIGEST: add to digest queue.
- Return created notification (for WebSocket push).

- `processEventBatch(events: EmitEvent[])` -- process multiple events efficiently (for batch submission). Iterate through events, calling processEvent for each. Consider wrapping in a database transaction for atomicity.

## Critical Security Rules

- Template variables are escaped before rendering -- prevents XSS via event metadata.
- Recipient resolution respects delegate permission boundaries -- no notifications for capabilities outside delegate scope.
- URGENT in-app notifications cannot be suppressed by preferences -- safety-critical events always visible.
- All processEvent calls must emit an audit event for traceability.

## Prerequisites

- D09-010 must be complete (notification repository for creating notifications).
- D09-011 must be complete (template repository for loading templates, delivery log for email queueing).
- D09-012 must be complete (preference repository, digest queue repository).
- Domain 1 delegate linkage repository must exist for resolving delegate permissions.

## Tests to Write

Add tests to `apps/api/src/domains/notification/notification.test.ts`:

- processEvent creates notification for physician
- processEvent creates notification for delegate with matching permission
- processEvent skips delegate without matching permission
- resolveRecipients returns physician and relevant delegates
- resolveRecipients excludes inactive delegates
- checkPreferences returns defaults for unconfigured category
- checkPreferences enforces URGENT in-app always enabled
- renderNotification substitutes variables correctly
- renderNotification escapes HTML in variable values
- renderNotification with missing variable throws error
- processEvent with IMMEDIATE digest mode queues email
- processEvent with DAILY_DIGEST mode adds to digest queue
- processEventBatch creates notifications for multiple events

## FRD Reference

- Domain 9 Section 6.1: Pipeline steps -- event received, recipient resolution, preference check, template rendering, notification creation, in-app delivery, email routing, delivery tracking.
- Domain 9 Section 4.3: Delegate notifications filtered by permissions. Permission-to-event mapping.
- Domain 9 Section 4.2: Default preferences -- URGENT in-app always on, HIGH/MEDIUM email on, LOW email off with daily digest.

## Run After Completion

```bash
pnpm --filter api vitest run src/domains/notification/notification.test.ts
```

All tests must pass before outputting [TASK_COMPLETE].
